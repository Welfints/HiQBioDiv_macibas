---
title: "5uzd_Rubene"
author: "Betija Rubene"
date: "2025-01-27"
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Piektais uzdevums: procesu dalīšana un rezultātu apvienošana

Darbam nepieciešamās pakotnes

```{r, message = FALSE, warning = FALSE}
library(terra)
library(tidyverse)
library(sf)
library(arrow)
library(sfarrow)
library(leaflet)
library(stringr)
```

# Sagatavošanās

Ielasu karti, no kuras jāizvēlas četras blakus esošas karšu lapas, kā arī meža datus un references rastrus

```{r}
karte <- st_read_parquet("../ref_vektori/tks93_50km.parquet")
mezi <- st_read_parquet("../centra_mezi/centra_mezi_labots.parquet")
#ref10m <- rast("../ref_rastri/LV10m_10km.tif")
#ref100m <- rast("../ref_rastri/LV100m_10km.tif")
```

Tā kā vēlāk šajā uzdevumā būs interesējoši skatīties uz lietām, kas notiek gar malām, būtu vērtīgi iemācīties izmantot pakotni leaflet. To arī varu izmantot lapu izvēlei.

Nav svarīgi, kā izvēlēties lapas - paņemšu lapas kaut kur pa vidu, jo strādājam ar centra virsmežniecības datiem

```{r, cache = TRUE}
crs(karte)
kartelatlon <- st_transform(karte, crs = 4326) # leaflet pieprasa WGS84
#mezilatlon <- st_transform(mezi, crs = 4326) # transformēšanas rezultātā radušās problēmas ar ģeometriju pārklāšanos, tas jāatrisina
#mezilatlon <- st_make_valid(mezi)

leaflet(kartelatlon) %>%
  addTiles() %>%  
  addPolygons(
    popup = ~paste("Attribute:", NUMURS) # gribu redzēt numuru uzklikšķinot
  )
```

Izvēlējos lapas 3333, 3334, 3331 un 3332, ievietoju tās atsevišķā objektā

```{r, warning = FALSE}
lapas <- karte %>% filter(NUMURS %in% c(3333,3334,3331,3332))
lapas_list <- split(lapas, lapas$NUMURS)
```
'
Lapas saglabāšu un tad izveidošu path sarakstu uz lapu failiem. Tādējādi būs iespējams nodrošināt failu ielasīšanu pašā funkcijā un pareizos failu nosaukumus izvades failā

```{r, warning = FALSE}
for (nr in names(lapas_list)) {
  data <- lapas_list[[nr]]  
  file_name <- paste0("lapa", nr, ".parquet") 
  st_write_parquet(data, file_name) 
}

lapas_list_paths <- list.files(pattern = "^lapa\\d{4}\\.parquet$", full.names = TRUE)
```

Jāpārvērš arī referenču crs, lai viss ir vienādi

```{r, warning = FALSE, cache = TRUE}
#ref10m <- project(ref10m, "EPSG:4326")
#ref100m <- project(ref100m, "EPSG:4326")
# spatRaster objekti, tāpēc nevar pielietot st_transform
rm(karte, lapas_list)
```

Iepriekšējā uzdevumā izveidotā funkcija, kurā bija nepieciešams veikt dažas izmaiņas. Ja pareizi esmu sapratusi uzdevuma būtību, tad references rastrus vajadzīgs apgriezt nevis ar lapu, bet ar atlasīto meža datu extent (crop to tā dara pēc nokusējuma) Tāds domu gājiens, jo uzdevuma premisē bija runa par rastru pārklāšanos - ja rastru apgriezīšu uzreiz ar pašu lapu, tad tiks daļēji pazaudēta informācija par uz lapas robežām esošajiem poligoniem, ja tādi būs radušies. Tas nozīmē, ka būs nepieciešams saglabāt arī izveidotos meža vektorfailus katrā uzdevumā

```{r}
dir.create("5uzd_faili") # visiem failiem lai mazinātu haosu

mana_funkcija <- function(mezs_dati, koku_suga, uzd_nr) {
numurs <- str_extract(mezs_dati, "(?<=lapa)\\d+")
mezs_dati <- st_read_parquet(mezs_dati)
ref10m <- rast(("../ref_rastri/LV10m_10km.tif"))
ref10m <- crop(ref10m, mezs_dati)
ref100m <- rast(("../ref_rastri/LV100m_10km.tif"))
ref100m <- crop(ref100m, mezs_dati)
faila_nos <- paste0("lapa", numurs,"_",uzd_nr, "_priedes100m")
fails <- file.path("5uzd_faili", paste0(faila_nos, ".tif"))
priezu_mezi <- mezs_dati %>% filter(s10 == koku_suga)
priezu_mezi_10m <- rasterize(priezu_mezi,ref10m, background = 0)
priezu_mezi_10m[is.na(ref10m)] <- NA
priezu_mezi_100m <-
  terra::resample(priezu_mezi_10m,ref100m,method="average",
                  filename = fails, overwrite=TRUE)
}
```

# 1) Spatial join

1.1. solis: izmantojot spatial join, saistiet MVR datus ar izvēlētajām karšu lapām (šis ir sākums laika mērogošanai). Kāds ir objektu skaits pirms un pēc savienošanas? Apskatiet katrai kartes lapai piederīgos objektus - vai tie atrodas tikai kartes lapas iekšienē, vai ir iekļauti visi objekti, kas ir uz kartes lapas robežām?

Izmantoju spatial join.

```{r, message = FALSE}
# bet vispirms jātiek galā ar crs nesakritībām
st_crs(lapas_list[["3331"]])
st_crs(mezi)
# ir vienādas, bet cikls mazliet zemāk tāpat meta error par nesakritībām...
mezi <- st_transform(mezi, st_crs(lapas_list[["3331"]]))

for (i in lapas_list_paths) {
  lapa <- st_read_parquet(i)
  fails <- st_join(mezi, lapa, left = FALSE)
  basename <- tools::file_path_sans_ext(basename(i))
  nosaukums <- file.path("5uzd_faili", paste0(basename,"mezi_1uzd.parquet"))
  st_write_parquet(fails, nosaukums)
}

# vienkāršā veidā paskatīšos vienu karti, vai izskatās ok
parbaude <- st_read_parquet("5uzd_faili/lapa3331mezi_1uzd.parquet")
plot(st_geometry(parbaude))
rm(pabraude)

# saglabāto failu saraksts ko pielietot ciklā
uzd1_mezi_file_paths <- list.files("5uzd_faili", pattern = "^lapa\\d{4}mezi_1uzd\\.parquet$", full.names = TRUE)
```

Pirms savienošanas objektā mezi ir 505654 objekti, katrā lapā piederīgi ir 15729, 29042, 33449 un 32904 objekti.

Paskatīšu, kas notiek kartes lapas malās ar leaflet interaktīvo karti pirmajai kartes lapai:

```{r}
lapa3331 <- st_transform(lapas_list[["3331"]], crs = 4326)
#bet vēlāk noderēs arī pārējās
lapa3332 <- st_transform(lapas_list[["3332"]], crs = 4326)
lapa3333 <- st_transform(lapas_list[["3333"]], crs = 4326)
lapa3334 <- st_transform(lapas_list[["3334"]], crs = 4326)
lapa3331uzd1 <- st_transform(uzd1_1[[1]], crs = 4326)

leaflet() %>%
  addTiles() %>%
  addPolygons(data = lapa3331, color = "blue") %>%
  addPolygons(data = lapa3331uzd1, color = "green") 

rm(lapa3331uzd1)
```

Kartes lapai piederīgie objekti, kā jau bija sagaidāms no funkcijas st_join, ir visi, kuri kaut vai daļēji ietilpst kartes lapā. Tātad iekļauti arī tie objekti, kas atrodas uz lapas malām

Saglabāšu 

1.2. solis - iteratīvā ciklā izmantojiet pārskatīto funkciju no uzdevuma sākuma, lai saglabātu katras karšu lapas rezultātu savā GeoTIFF failā, kura nosaukums ir saistāms ar šo apakšuzdevumu un individuālo lapu. Kā izskatās šūnu aizpildījums pie karšu lapu malām? Vai ir saglabājušies objekti ārpus kartes lapām?

Pielietoju funkciju:

```{r}
for (i in seq_along(uzd1_mezi_file_paths)) {
  mana_funkcija(mezs_dati = uzd1_mezi_file_paths[i], koku_suga = 1, uzd_nr = "1uzd")
}

rezultats <- rast("5uzd_faili/lapa3331_1uzd_priedes100m.tif")
plot(rezultats) # Ir ok
rm(rezultats)
```

1.3 solis  apvienot izveidotos rastrus vienā slānī

Sākumā gribu paskatīties, kā izskatās divas no lapām, jo sagaidāma pārklāšanās

```{r}
# pirmais rastrs
lapa3331_priedes_1uzd <- rast("5uzd_faili/lapa3331_1uzd_priedes100m.tif")
lapa3331_priedes_1uzd <- project(lapa3332_priedes_1uzd, st_crs(lapa3331)$wkt)

#otrais rastrs
lapa3332_priedes_1uzd <- rast("5uzd_faili/lapa3332_1uzd_priedes100m.tif")
lapa3332_priedes_1uzd <- project(lapa3332_priedes_1uzd, st_crs(lapa3331)$wkt)

leaflet() %>%
  addTiles() %>%
  addRasterImage(lapa3331_priedes_1uzd, group = "rastrs3331") %>%
  addRasterImage(lapa3332_priedes_1uzd, group = "rastrs3332") %>%
  addPolygons(data = lapa3331, color = "blue") %>%
  addPolygons(data = lapa3332, color = "blue") %>%
  addLayersControl(
    overlayGroups = c("rastrs3331","rastrs3332"),
    options = layersControlOptions(collapsed = FALSE))
```

Nu vispār neizskatās baigi labi, ir dažādi malu platumi. Bet redzams, ka rastrs ir arī ārpus lapas, kas bija sagaidāms, kā arī tas, ka vietās, kur rastri pārklājas, abos rastros vērtības nesakrīt. Pie malām vērtības vienmēr ir mazas, jo poligoni, kas ir bijuši tieši ārpus atlasītajiem mežiem, nav ņemti vērā (tie šīs malu vērtības teorētiski daļā gadījumu varēja ietekmēt)

Vai tiem dažādajiem malu platumiem ir saistība ar ar to, ka mētājos pa dažādām koordinātu sistēmām, jo leaflet karte pieprasa WGS84 (esmu par to iepriekš domājusi, cik daudz un kādas kļūdas var rasties, transformējot crs, labprāt to apmācību laikā apspriestu)? Vai tas vienkārši ir rastra šūnu izvietojuma dēļ? 

Negribēju visu laiku darboties WGS84 koordinātu sistēmā, jo premisē minēts, ka projektā pastāvīgi strādāsim ar LKS-92


Izveidoju sarakstu ar ceļiem uz visiem radītajiem failiem, tad apvienoju rastrus un apskatu rezultātu.

Jādomā par to, ko darīt ar malām, kuras pārklājas. Negribu, lai viena rastra vērtības ir svarīgākas par otrām, jo, kā redzams augstāk kartē, rastri krietni iestiepjas arī blakus lapā. Ttāpēc izmantošu terra:mosaic ar fun = max, lai ņemtu vērā maksimālo vērtību no pārklāšanās vietām (centīšos paskaidrot domu, bet kaut kā nesanāk veikli - ja jau vienā lapā mežu īpatsvars tika aprēķināts, tad tas noteikti ir vismaz tik liels konkrētajā šūnā)

```{r}
uzd1_priedes_file_paths <- list.files("5uzd_faili", pattern = "^lapa\\d{4}_1uzd_priedes100m\\.tif$", full.names = TRUE)
uzd1_priedes <- lapply(uzd1_priedes_file_paths, rast)

uzd1_priedes_merged <- do.call(mosaic, uzd1_priedes)
plot(uzd1_priedes_merged)
writeRaster(uzd1_priedes_merged, "Uzd1_priedes100m_merged.tif", overwrite = TRUE)
```

```{r}
leaflet() %>%
  addTiles() %>%
  addRasterImage(uzd1_priedes_merged) %>%
  addPolygons(data = lapa3331, color = "blue", group = "lapa") %>%
  addPolygons(data = lapa3332, color = "blue", group = "lapa") %>%
  addPolygons(data = lapa3333, color = "blue", group = "lapa") %>%
  addPolygons(data = lapa3334, color = "blue", group = "lapa") %>%
  addLayersControl(
    overlayGroups = "lapa",
    options = layersControlOptions(collapsed = FALSE))
```

Neesmu droša, kas notiek ar augšējo kreiso lapu...
Bet tā kopumā karšu lapu robežas izteikti nav redzamas, lai gan dažviet ir mazākas vērtības vietās, kur robežojas lapu malas. Man šķiet, ka strādājot būtu vērtīgi ieviest buferi, lai malās nekas nepazustu - jo šobrīd izskatās, ka, tā kā poligoni, kas ir bijuši tieši ārpus atlasītajiem mežiem, nav ņemti vērā, tad pie pašas malas kaut kāda informācija var būt zaudēta.

Lai mērītu laiku, es visas uz apakšuzdevumiem tieši attiecināmās komandrindas sarakstīju kompakti (zemāk), ļoti vēlos atstāt visu savu domu gaitu, pārbaudes un bildītes (augstāk)

```{r, warning = FALSE}
SakumsUzd1 <- Sys.time()

# 1.1. solis
for (i in lapas_list_paths) {
  lapa <- st_read_parquet(i)
  fails <- st_join(mezi, lapa, left = FALSE)
  basename <- tools::file_path_sans_ext(basename(i))
  nosaukums <- file.path("5uzd_faili", paste0(basename,"mezi_1uzd.parquet"))
  st_write_parquet(fails, nosaukums)
}

# 1.2. solis
for (i in seq_along(uzd1_mezi_file_paths)) {
  mana_funkcija(mezs_dati = uzd1_mezi_file_paths[i], koku_suga = 1, uzd_nr = "1uzd")
}

# 1.3. solis
uzd1_priedes_merged <- do.call(mosaic, uzd1_priedes)

BeigasUzd1 <- Sys.time()
print(BeigasUzd1 - SakumsUzd1)
```

šis viss aizņema mazliet vairāk nekā minūti.

# 2) Clipping





