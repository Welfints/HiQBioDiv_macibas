---
title: "6uzd_Rubene"
author: "Betija Rubene"
date: "2025-02-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Sestais uzdevums: dažādu slāņu savienošana vienotai ainavas aprakstīšanai

Darbam nepieciešamās pakotnes

```{r, message = FALSE, warning = FALSE}
library(terra)
library(sfarrow)
library(tidyverse)
library(fasterize)
library(sf)
```

Uzdevuma ietvaros veidojamo rastru pārklājumam un šūnu novietojumam ir jāsakrīt ar projekta Zenodo repozitorijā ievietoto references slānim LV10m_10km.tif. Rasterizēšanas nosacījumam izmantojiet šūnas centru.

# 1) LAD datu rasterizēšana

Rasterizējiet Lauku atbalsta dienestā reģistrētos laukus, izveidojot klasi “100” (vai izmantojiet trešajā uzdevumā sagatavoto slāni, ja tas ir korekts).

3. uzdevumā izveidotais rastra slānim vajadzētu būt korektam (veidots ar noklusējuma argumentu touches = FALSE, lai rasterizēšanas nosacījumam tiktu izmantots šūnas centrs), vienīgā atšķirība no prasītā ir tajā, ka lauki atzīmēti ar vērtību "1" nevis "100". To nomainu ar funkciju subst.

```{r, message = FALSE}
LAD10m <- rast("../LAD_dati/LAD_lauki_10m.tif")
crs(LAD10m) # LKS-92
LAD10m <- subst(LAD10m, 1, 100) # aizstāj vērtības 1 ar 100
plot(LAD10m)
```

# 2) MVR datu rastra slāņu izveidošana

Izveidojiet rastra slāņus ar skujkoku (klase “204”), šaurlapju (klase “203”), platlapju (klase “202”) un jauktu koku mežiem (klase “201”) no sevis ierosinātās klasifikācijas otrajā uzdevumā.

Tātad būs jāstrādā ar centra virsmežniecības vektordatiem:

```{r}
MVRdati <- st_read_parquet("../centra_mezi/centra_mezi_labots.parquet")
```

Iepriekš nebiju pamanījusi, ka šajos datos ne viss ir mežaudzes, tas uzrādās laukā zkat - ar kodu 10 atzīmētas mežaudzes. Atlasīšu tikai tās:

```{r}
MVRdati <- MVRdati %>%
  filter(zkat == 10)
# filtrējot tika atmesti ~ 40 000 lauki
```

Atkal jānodefinē, kuras koku sugas ierindoju kurā kategorijā (pieeju nokopēju no 2. uzdevuma):

```{r}
skujkoki <- c(1,3,13,14,15,22,23,28,29)
platlapji <- c(8,9,10,11,12,16,17,18,21,24,25,26,27,32,35,50,61,62,63,64,65,66,67,69)
saurlapji <- c(4,6,19,20,68)
```

Izmantošu komandrindas no 2. uzdevuma, lai ieviestu kolonnas ar meža tipiem, kuros uzrādās procentuālais šķērslaukums katrā koku grupā. Gan jau to kaut kā kompaktāk var uzrakstīt, bet ir tikai trīs grupas, tāpēc es tam šobrīd laiku netērēšu:

```{r}
# kopējā šķērslaukuma aprēķins
MVRdati <- MVRdati %>% 
  mutate (skerslaukums = g10 + g11 + g12 + g13 + g14)

# šķērslaukuma aprēķins skujkokiem, platlapjiem un šaurlapjiem
MVRdati <- MVRdati %>% 
  mutate (skujkoki = 
ifelse(s10 %in% skujkoki, g10, 0) +
ifelse(s11 %in% skujkoki, g11, 0) +
ifelse(s12 %in% skujkoki, g12, 0) +
ifelse(s13 %in% skujkoki, g13, 0) +
ifelse(s14 %in% skujkoki, g14, 0))

MVRdati <- MVRdati %>% 
  mutate (platlapji = 
ifelse(s10 %in% platlapji, g10, 0) +
ifelse(s11 %in% platlapji, g11, 0) +
ifelse(s12 %in% platlapji, g12, 0) +
ifelse(s13 %in% platlapji, g13, 0) +
ifelse(s14 %in% platlapji, g14, 0))

MVRdati <- MVRdati %>% 
  mutate (saurlapji = 
ifelse(s10 %in% saurlapji, g10, 0) +
ifelse(s11 %in% saurlapji, g11, 0) +
ifelse(s12 %in% saurlapji, g12, 0) +
ifelse(s13 %in% saurlapji, g13, 0) +
ifelse(s14 %in% saurlapji, g14, 0))
```

Tad aprēķinu katras grupas īpatsvaru mežaudzē

```{r}
MVRdati <- MVRdati %>% 
  mutate (prop_skujkoki = skujkoki/skerslaukums*100)

MVRdati <- MVRdati %>% 
  mutate (prop_saurlapji = saurlapji/skerslaukums*100)

MVRdati <- MVRdati %>% 
  mutate (prop_platlapji = platlapji/skerslaukums*100)
```

Visbeidzot ieviešu kolonnu, kurā nodefinēts meža tips, izmantojot 75% slieksni (pieder konkrētajai kategorijai, ja šķērslaukums sasniedz vismaz 75%, ja nevienā grupā slieksnis netiek sasniegts, tad tas klasificēts kā jauktu koku mežs)

Kategoriju kodējums atbilstoši aprakstā prasītajam:  
Skujkoku meži - 204   
Šaurlapju meži - 203  
Platlapju meži - 202  
Jauktu koku meži - 201 

Ja nav datu par kokiem, funkcija atgriezīs vērtību NA. Var jau būt, ka citās situācijās būtu vajadzīgs šai grupai iedot vērtību, tomēr šoreiz es tam neredzu jēgu un arī uzdevuma nosacījumos par to nekas nav teikts - vajadzīgs tikai kodēt pēc meža tipa.

```{r}
MVRdati <- MVRdati %>%
  mutate(
    meza_grupa = case_when(
      !is.na(prop_skujkoki) & prop_skujkoki >= 75 ~ 204,  
      !is.na(prop_saurlapji) & prop_saurlapji >= 75 ~ 203,
      !is.na(prop_platlapji) & prop_platlapji >= 75 ~ 202,
      (!is.na(prop_skujkoki) & prop_skujkoki > 0) |
      (!is.na(prop_saurlapji) & prop_saurlapji > 0) |
      (!is.na(prop_platlapji) & prop_platlapji > 0) ~ 201
    )
  )
```

Rasterizēju datus, balstoties uz kolonnu meza_grupa. Man no 3. uzdevuma prātā bija palicis, ka ar rasterize viss notika ātrāk, bet pamēģināšu arī fasterize

```{r, message = FALSE}
crs(MVRdati) # ir LKS-92
ref10m <- rast("../ref_rastri/LV10m_10km.tif") # 10m references rastrs

system.time(
  MVRrastrs1 <- rasterize(MVRdati,ref10m, field = "meza_grupa")) 
# 119 sek

class(ref10m)
ref10m_rast <- raster(ref10m) # fasterize grib RasterLayer
system.time(
  MVRrastrs2 <- fasterize(MVRsf,ref10m_rast, field = "meza_grupa")) 
# 82 sek
# labi, turpmāk izmantošu fasterize, tomēr šoreiz palikšu pie ar rasterize izveidotā objekta, jo tas ir terra objekts
rm(MVRrastrs2)
```

# 3) Papildināšana ar vecuma grupu

Papildieniet otrā punkta rastrus, izveidojot jaunus slāņus, ar informāciju par mežaudzes vecuma grupu kā klases vērtības otro ciparu. Dalījumam mežaudžu vecuma grupās, izmantojiet vecumgrupas un vecumklases un, aprēķinot galvenās cirtes vecumu, pieņemiet “I un augstāka” bonitāti.

DBF spefizikācijas failā ir informācija par mežaudžu vecuma grupu klasifikatoru, tomēr MVR datos es šādu kolonnu neatrodu...

```{r}
"vgr" %in% colnames(MVRdati) # :(
```

Tāpēc vecumgrupas jāaprēķina pašai.



